# TIL 2021 - 08 - 02  📖 !

- sprint

1. 토큰의 개념을 이해할 수 있다.
- jwt 인증 순서 
  1. 사용자가 로그인을 한다.
  2. 서버에서는 계정정보를 읽어 사용자를 확인 후, 사용자의 고유한 ID값을 부여한 후, 기타 정보와 함께 Payload에 넣습니다.
  3. JWT 토큰의 유효기간을 설정합니다.
  4. 암호화할 SECRET KEY를 이용해 ACCESS TOKEN을 발급합니다.
  5. 사용자는 Access Token을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보냅니다.
  6. 서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 복호화한 후, 조작 여부, 유효기간을 확인합니다.
  7. 검증이 완료된다면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져옵니다.  



 - 토큰의 기본 구조 
 JWT의 기본 구조
 Header . Payload . Signature
 JWT는 헤더(header), 페이로드(payload), 서명(signature) 세 가지로 나눠져 있습니다

- header 의 구조
 Header
 헤더에는 typ와 alg 두 가지 정보로 구성되어 있습니다.

  typ
  토큰의 타입을 지정 (jwt)
  alg
  해싱 알고리즘을 지정

  주로 HMAC SHA256(해싱. 암호화기능) 또는 RSA를 사용하며 이 알고리즘은 서명(signature)에서 사용합니다.
  헤더 형태는 아래와 같습니다.
 ```
 {
     'alg': 'HS256',
     "typ": "JWT"
 }
```
- Payload

 페이로드라 불리는 부분에는 토큰에서 사용할 정보가 담겨있고 이를 위에서 설명한 클레임이라 부르는 것들이 저장되어 있습니다
 Key/Value 방식으로 이뤄져있으며 (JSON과 유사) 다수의 정보를 넣을 수 있습니다
 이 클레임은 총 세 가지로 나뉩니다.



 등록된 클레임 (Registered Claim)
 등록된 클레임은 토큰 정보를 표현하기 위해 이미 정해진 데이터 종류이며, 모두 선택적으로 작성 가능합니다.
 종류는 아래와 같습니다.

    - iss: 토큰 발급자 (issuer)
    - sub: 토큰 제목 (subject)
    - aud: 토큰 대상자 (audience)
    - exp: 토큰의 만료시간 (expiraton)
    - NumericDate 형식으로 되어있어야 합니다 (Ex: 1480849147370
    - nbf: 토큰 활성 날짜, 이 날짜가 지나기 전 토큰은 활성화 되지 않습니다.
    - iat: 토큰이 발급된 시간 (issued at), 이 값을 사용하여 토큰 발급 이후 얼마나 시간이 지났는지를 알 수 있습니다.
    - jti: JWT의 고유 식별자 , 중복 방지를 위해 사용하며, 일회용 토큰(Access Token 등)에 사용합니다.


공개 클레임 (Public Claim)
공개 클레임은 서로 충돌이 일어나지 않는 이름을 가지고 있어야합니다.
그래서 URL 형태로 작성하며 예시는 아래와 같습니다.
```
{ 
    "https://hexlant.com": true 
}
```

비공개 클레임 (Private Claim)
비공개 클레임은 실제 사용을 하는 개발자가 지정하는 것으로 서버와 클라이언트가 서로 정의하여 사용하는 클레임을 의미합니다.
아래와 같이 사용하기도 합니다.
```
{
     "token_type": "access"
}
```
결론적으로 페이로드는 아래와 같이 구성됩니다.
```
{
    'sub': '1234567890'
    'name': 'John Doe'
    'iat': 1516239022
}
```

- Signature

 서명은 위에서 만든 Header와 Payload 의 각 값을 BASE64로 인코딩 하고, 그 값을 비밀키를 이용해 헤더에서 정의한 알고리즘으로 (HS256이나 SHA256 등) 해싱을 하고, 이 값을 다시 BASE64로 인코딩하여 생성합니다.

- JWT 장점
 
  - JWT 의 주요한 이점은 사용자 인증에 필요한 모든 정보는 토큰 자체에 포함하기 때문에 별도의 인증 저장소가 필요없다는 것입니다.

   - 분산 마이크로 서비스 환경에서 중앙 집중식 인증 서버와 데이터베이스에 의존하지 않는 쉬운 인증 및 인가 방법을 제공합니다.

   -  개별 마이크로 서비스에는 토큰 검증과 검증에 필요한 비밀 키를 처리하기위한 미들웨어가 필요합니다. 검증은 서명 및 클레임과 같은 몇 가지 매개 변수를 검사하는 것과 토큰이 만료되는 경우로 구성됩니다.

 토큰이 올바르게 서명되었는지 확인하는 것은 CPU 사이클을 필요로하며 IO 또는 네트워크 액세스가 필요하지 않으며 최신 웹 서버 하드웨어에서 확장하기가 쉽습니다.

- JSON 웹 토큰의 사용을 권장하는 몇 가지 이유?

  - URL  파라미터와 헤더로 사용
  - 수평 스케일이 용이
  - 디버깅 및 관리가 용이
  - 트래픽 대한 부담이 낮음
  - REST 서비스로 제공 가능
  - 내장된 만료
  - 독립적인 JWT

 - 다음과 같은 상황에서 JWT 가 유용하게 사용 될 수 있습니다.

   - 회원 인증: JWT 를 사용하는 가장 흔한 시나리오 입니다. 사용자가 로그인을 하면, 서버는 사용자의 정보를 기반으로한 토큰을 발급합니다.
  그 후, 사용자가 서버에 요청을 할 때 마다 JWT를 포함하여 전달합니다. 서버는 클라이언트에서 요청을 받을때 마다, 해당 토큰이 유효하고 인증됐는지 검증을 하고, 사용자가 요청한 작업에 권한이 있는지 확인하여 작업을 처리합니다.
  서버에서는 사용자에 대한 세션을 유지 할 필요가 없습니다. 즉 사용자가 로그인되어있는지 안되어있는지 신경 쓸 필요가 없고, 사용자가 요청을 했을때 토큰만 확인하면 되므로 세션 관리가 필요 없어서 서버 자원과 비용을 절감할 수 있습니다.
   
   - 정보 교류: JWT는 두 개체 사이에서 안정성있게 정보를 교환하기에 좋은 방법입니다. 그 이유는, 정보가 서명이 되어있기 때문에 정보를 보낸이가 바뀌진 않았는지, 또 정보가 도중에 조작되지는 않았는지 검증할 수 있습니다

2. 쿠키 / 세션 방식과의 차이를 이해할 수 있다.

  - 세션의 인증 절차 

    1. 사용자가 로그인을 합니다.

    2. 서버에서는 계정 정보를 읽어 사용자를 확인 후, 사용자의 고유 ID 값을 부여한 후 세션 저장소에 저장하고, 이와 연결되는 세션 ID 를 발행합니다.

     3. 클라이언트는 서버에서 해당 세션 ID 를 받아 쿠키에 저장 한 후, 인증이 필요한 요청마다 쿠키를 헤더에 끼워 보냅니다.

     4. 서버에서는 쿠키를 받아 세션 저장소에서 확인 한 후, 일치하는 정보를 가져옵니다.

    5.  인증이 완료되고 서버는 사용자에 맞는 데이터를 보내줍니다.

 - 세션과 쿠키의 차이점 
     - Session
  서버에서 가지고있는 정보
      - Cookie
  서버에서 발급된 세션을 열기 위한 키 값(세션 ID 라고 칭함)
  쿠키만으로 인증을 한다는 것은서버의 자원은 사용하지 않는다는 것 - 클라이언트가 인증 정보를 책임지는 것을 의미합니다.

   쿠키만으로 인증을 할 경우, 해커가 HTTP 요청을 중간에서 뺏어갈 때, 모든 정보가 탈취됩니다.

   또한 쿠키는 조작된 데이터일 수 있으므로 실제 정보가 존재하는 database 를 사용해서 작업합니다.

  따라서 보안과는 관련 없는 장바구니, 자동로그인 설정 같은 경우에 유용하게 사용됩니다.

  - 토큰의 인증절차 
    1. 사용자가 로그인을 합니다.

    2. 서버에서는 계정 정보를 읽어 사용자를 확인 후, 사용자의 고유 ID 값을 부여한 후 기타 정보와 함께 Payload 에 집어넣습니다.

     3. JWT 토큰의 유효기간을 설정합니다.

     4. 암호화할 Secret key 를 이용해 Access Token 을 발급합니다.

    5. 사용자는 Access Token 을 받아 저장 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보냅니다.

    6. 서버에서는 해당 토큰의 Verify Signature 를 Secret key 로 복호화한 후, 조작 여부, 유효기간을 확인합니다.

    7. 검증이 완료되었을 경우, Payload 를 디코딩 하여 사용자의 ID 에 맞는 데이터를 가져옵니다.

    세션 / 쿠키 방식과 가장 큰 차이점은 세션 / 쿠키는 세션 저장소에 유저 정보를 넣는 반면, JWT 는 토큰 안에 유저의 정보들이 넣어진다는 점 입니다. 
    
    클라이언트 입장에서는 HTTP 헤더에 세션 ID 나 토큰을 실어서 보내준다는 점에선 동일하지만, 서버 측에서는 인증을 위해 암호화를 한다 vs 별도의 저장소를 이용한다 의 차이가 발생합니다.

    간단하게 예를 들자면 아파트에 사는 사람을 클라이언트 라고 예를 듭니다 .

    세션의 예입니다 .

    클라이언트는 아파트 공동 현관문의 카드키만 있다면 카드를 찍고 엘리베이터를 이용할 수 있고 집에 들어 갈 수 있습니다 . 
    공동현관문 하나만 통과 하면 됩니다 .

    토큰의 예입니다 .

    호텔을 이용하는 투숙객을 예로 듭니다 .

    이름이 있는 호텔들은 사용자가 카드를 들고 다니고 내 방에 들어 갈 때에 엘리베이터를 사용 할 때에 아니면 조식을 예약 할 때에 등 모든 일들에 보통 사용자의 카드가 필요 합니다  카드를 잃어버리게 되면 엘리베이터 조차 탈 수 없습니다 .

    이렇게 클라이언트는 토큰을 가지고 다니면서 이곳 저곳에서 활동 할 수 있는 인증을 받을 수 있는것과 비슷 합니다 따라서 여러개의 서버를 운용하고 서버를 확장시킬 필요가 있을 때에 용이합니다 . 
    
    하지만 세션같은 경우에는 여러개의 서버가 있을 경우에 각각의 서버의 세션 저장소마다 각기 다른 정보가 저장 되어 있을 수도 있어 여러개의 서버를 운용하는데에 불편함이 있습니다  


3. 토큰 방식의 한계를 이해할 수 있다.
- JWT 단점

  - 토큰은 클라이언트에 저장되어 데이터베이스에서  사용자 정보를 조작하더라도 토큰에 직접 적용할 수 없습니다.

   - 더 많은 필드가 추가되면 토큰이 커질 수 있습니다.
  비상태 애플리케이션에서 토큰은 거의 모든 요청에 대해 전송되므로 데이터 트래픽 크기에 영향을 미칠 수 있습니다.

   - 이미 발급된 JWT에 대해서는 돌이킬 수 없습니다. 세션/쿠키의 경우 만일 쿠키가 악의적으로 이용된다면, 해당하는 세션을 지워버리면 됩니다. 하지만 JWT는 한 번 발급되면 유효기간이 완료될 때 까지는 계속 사용이 가능합니다. 따라서 악의적인 사용자는 유효기간이 지나기 전까지 신나게 정보들을 털어갈 수 있습니다. 
 -> 해결책
 기존의 Access Token의 유효기간을 짧게 하고 Refresh Token이라는 새로운 토큰을 발급합니다. 그렇게 되면 Access Token을 탈취당해도 상대적으로 피해를 줄일 수 있습니다. 이는 다음 포스팅에 나올 Oauth2에 더 자세히 다루도록 하겠습니다.
 
  - Payload 정보가 제한적입니다. 위에서 언급했다시피 Payload는 따로 암호화되지 않기 때문에 디코딩하면 누구나 정보를 확인할 수 있습니다. (세션/쿠키 방식에서는 유저의 정보가 전부 서버의 저장소에 안전하게 보관됩니다) 따라서 유저의 중요한 정보들은 Payload에 넣을 수 없습니다.
 
  - JWT의 길이입니다. 세션/쿠키 방식에 비해 JWT의 길이는 깁니다. 따라서 인증이 필요한 요청이 많아질 수록 서버의 자원낭비가 발생하게 됩니다.
