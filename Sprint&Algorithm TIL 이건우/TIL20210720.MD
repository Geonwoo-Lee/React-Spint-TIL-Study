짐 나르기
문제
김코딩과 박해커는 사무실 이사를 위해 짐을 미리 싸 둔 뒤, 짐을 넣을 박스를 사왔다. 박스를 사오고 보니 각 이사짐의 무게는 들쭉날쭉한 반면, 박스는 너무 작아서 한번에 최대 2개의 짐 밖에 넣을 수 없었고 무게 제한도 있었다.

예를 들어, 짐의 무게가 [70kg, 50kg, 80kg, 50kg]이고 박스의 무게 제한이 100kg이라면 2번째 짐과 4번째 짐은 같이 넣을 수 있지만 1번째 짐과 3번째 짐의 무게의 합은 150kg이므로 박스의 무게 제한을 초과하여 같이 넣을 수 없다.

박스를 최대한 적게 사용하여 모든 짐을 옮기려고 합니다.

짐의 무게를 담은 배열 stuff와 박스의 무게 제한 limit가 매개변수로 주어질 때, 모든 짐을 옮기기 위해 필요한 박스 개수의 최소값을 return 하도록 movingStuff 함수를 작성하세요.

입력
인자 1: stuff
Number 타입의 40 이상 240 이하의 자연수를 담은 배열
ex) [70, 50, 80, 50]
인자 2: limited
Number 타입의 40 이상 240 이하의 자연수
출력
Number 타입을 리턴해야 합니다.
모든 짐을 옮기기 위해 필요한 박스 개수의 최솟값을 숫자로 반환합니다.
주의사항
옮겨야 할 짐의 개수는 1개 이상 50,000개 이하입니다.
박스의 무게 제한은 항상 짐의 무게 중 최대값보다 크게 주어지므로 짐을 나르지 못하는 경우는 없습니다.
입출력 예시

```
let output = movingStuff([70, 50, 80, 50], 100);
console.log(output); // 3
```
```js
let output = movingStuff([60, 80, 120, 90, 130], 140);
console.log(output); // 4
12345678910111213141516
function movingStuff(stuff, limit) {
  //짐의 무게를 오름차순으로 정렬해서 접근한다 ㅇ
  //짐의 크기가 큰것과 작은것을 구한다ㅇ
  //박스 두개를 담을 변수 count를 선언하고 초기값으로는 0을 할당한다ㅇ
  //반복되는 loop를 생성하여서 큰 짐이 작은짐보다 클때까지ㅇ
  //큰짐과 작은짐의 합이 limit이하이면 count ++ 작은짐++ 큰짐은 --
  //큰짐과 작은짐의 합이 limit초과하면 큰짐--
  //리턴값에는 stuff배열의 길이에서 count를 빼주면 박스의 최소값이 나온다
  let count = 0
  let sorted = stuff.sort((a, b) => a - b)
…    }
  }
  return stuff.length - count
}
```

문제
편의점에서 아르바이트를 하고 있는 중에, 하필이면 피크 시간대에 손님에게 거스름돈으로 줄 동전이 부족하다는 것을 알게 되었습니다.
현재 가지고 있는 동전은 1원, 5원, 10원, 50원, 100원, 500원으로 오름차순으로 정렬되어 있고, 각 동전들은 서로 배수 관계에 있습니다.
동전 개수를 최소화하여 거스름돈 K를 만들어야 합니다. 이때, 필요한 동전 개수의 최솟값을 구하는 함수를 작성해 주세요.

입력
인자: k
number 타입의 k
1 <= k <= 100,000,000
출력
number 타입의 거스름돈 K원을 만드는데 필요한 동전 개수의 최솟값을 반환해야 합니다.
입출력 예시
// 4000원을 받았을 때 500원짜리 동전 8개를 반환합니다.
```
const output1 = test1(4000);
console.log(output1); // --> 8
```
// 4972원을 받았을 때 500원짜리 동전 9개, 100원짜리 동전 4개, 50원짜리 동전 1개, 10원짜리 동전 2개, 1원짜리 동전 2개, 총 18개를 반환합니다.
```
const output2 = test1(4972);
console.log(output2); // --> 18
```
```js
function partTimeJob(k) {
//가지고있는 동전의 배열을 만들어준다 
//Poket
//동전의 갯수를 세기 위한 count생성
//배열의 값을 오름차순으로 정렬해준다
//배열의 가장 큰값을 구해준다
// 가장 큰 값은 max
//가장 큰 값부터 k에 비교를 해준다
//반복되는 loop를 생성해서 가장 큰 값이 0 이상 일때 까지
//k % poket의 max 가 0 이면 count = count + 몫
//break를 걸어주지 않으면 무한루프 
//k % poket max 가 0이 아니면 count = count + 몫
// max--
//나머지 금액을 다음 poket max 에 전달
//k의 값이 0이 될 때 까지 반복하고 
//0이 되면 루프를 빠져나와서//count를 리턴


  let poket = [1, 5, 10, 50, 100, 500]
  let count = 0
  let max = poket.length-1

  while(max >= 0){
    let moks =  k / poket[max]
    if( k % poket[max] === 0 ){
      count = count + moks
      break
    }else{
      count = count + Math.floor( moks )
      k = k % poket[max]
      max--
    }
  }
  return count
}

```

보드 게임
문제
N * N의 크기를 가진 보드판 위에서 게임을 하려고 합니다. 게임의 룰은 다음과 같습니다.

좌표 왼쪽 상단(0, 0)에 말을 놓는다.
말은 상, 하, 좌, 우로 이동할 수 있고, 플레이어가 조작할 수 있다.
조작의 기회는 딱 한 번 주어지며, 최대 N * 2 번까지 이동할 수 있다.
조작할 때 U, D, L, R은 각각 상, 하, 좌, 우를 의미하며 한 줄에 띄어쓰기 없이 써야 한다.
예시: UDDLLRRDRR, RRRRR
한 번 움직일 때마다 한 칸씩 움직이게 되며, 그 칸 안의 요소인 숫자를 획득할 수 있다.
방문한 곳을 또 방문해도 숫자를 획득할 수 있다.
보드 밖을 나간 말은 OUT 처리가 된다.
칸 안의 숫자는 0 또는 1이다.
단, 좌표 왼쪽 상단(0, 0)은 항상 0이다.
획득한 숫자를 합산하여 숫자가 제일 큰 사람이 이기게 된다.
보드판이 담긴 board와 조작하려고 하는 문자열 operation이 주어질 때, 말이 해당 칸을 지나가면서 획득한 숫자의 합을 구하는 함수를 작성하세요.

입력
인자 1: board
number 타입의 2차원 배열
2 <= board.length <= 1,000
예: [ [0, 0, 1], [1, 0, 1], [1, 1, 1] ]
인자 2: operation
string 타입의 대문자 영어가 쓰여진 문자열

1 <= operation.length <= board.length * 2

U, L, D, R 이외의 문자열은 없습니다.
출력
Number 타입을 반환해야 합니다.
board와 operation이 입력값의 예시 ([ [0, 0, 1], [1, 0, 1], [1, 1, 1] ], DDR)일 때, (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) 순서로 이동하게 되고, 각 0, 1, 1, 1을 얻어 3을 반환합니다.
주의사항
만약, 말이 보드 밖으로 나갔다면 즉시 OUT 을 반환합니다.
입출력 예시
```
const board1 = [
  [0, 0, 0, 1],
  [1, 1, 1, 0],
  [1, 1, 0, 0],
  [0, 0, 0, 0]
]
const output1 = boardGame(board1, 'RRDLLD');
console.log(output1); // 4
```
```
const board2 = [
  [0, 0, 1],
  [1, 1, 1],
  [1, 0, 0]
]
const output2 = boardGame(board2, 'UUUDD');
console.log(output2); // 'OUT'
```
```
const board3 = [
  [0, 0, 0, 0, 0],
  [0, 0, 1, 0, 0],
  [0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0],
  [0, 0, 0, 0, 0]
]
const output3 = boardGame(board3, 'DDRRRUDUDUD');
console.log(output3); // 0
```
```js
function boardGame(board, operation) {
  //N = board.length N을 구해준다
  //지나온 칸의 합을 구해주는 count라는 변수를 만들어준다 초기값은 0으로 해준다
  //방향키의 설정을 해주고 움직임에 대한 배열을 만들어준다
  //그 뒤에 초기값을 0 으로 잡아준 row (열) col(행)에 어떤 값이 들어왔을때 그 값에 해당하는 것을 
  //더해준다
  //isValid함수를 통해 isValid함수의 값이 false 이면 'OUT'을 리턴한다
  const RIGHT = [0, 1];
  const DOWN = [1, 0];
  const LEFT = [0, -1];
…     if(isValid(row, col) === false){
       return 'OUT'
     }
     if(board[row][col] === 1 ){
       count++
     }
    }
  }
  return count
};
```

금고를 털어라
문제
자신이 감옥에 간 사이 연인이었던 줄리아를 앤디에게 빼앗겨 화가 난 조지는 브레드, 맷과 함께 앤디 소유의 카지노 지하에 있는 금고를 털기로 합니다. 온갖 트랩을 뚫고 드디어 금고에 진입한 조지와 일행들. 조지는 이와중에 감옥에서 틈틈이 공부한 알고리즘을 이용해 target 금액을 훔칠 수 있는 방법의 경우의 수를 계산하기 시작합니다.

예를 들어 $50 을 훔칠 때 $10, $20, $50 이 있다면 다음과 같이 4 가지 방법으로 $50을 훔칠 수 있습니다.

$50 한 장을 훔친다
$20 두 장, $10 한 장을 훔친다
$20 한 장, $10 세 장을 훔친다
$10 다섯 장을 훔친다
훔치고 싶은 target 금액과 금고에 있는 돈의 종류 type 을 입력받아, 조지가 target 을 훔칠 수 있는 방법의 수를 리턴하세요.

입력
인자 1: target
Number 타입의 100,000 이하의 자연수
인자 2: type
Number 타입을 요소로 갖는 100 이하의 자연수를 담은 배열
출력
Number 타입을 리턴해야 합니다.
조지가 target을 훔칠 수 있는 방법의 수를 숫자로 반환합니다.
주의사항
모든 화폐는 무한하게 있다고 가정합니다.
입출력 예시
```
let output = ocean(50, [10, 20, 50]);
console.log(output); // 4

let output = ocean(100, [10, 20, 50]);
console.log(output); // 10

let output = ocean(30, [5, 6, 7]);
console.log(output); // 4
```
Hint!
해당 문제는 냅색 알고리즘(Knapsack Problem)을 활용하여 풀 수 있습니다.
검색해 보시고, 연구해 보세요!

```js
function ocean(target, type) {
    // 배열을 하나 만들어 준다. 길이는 target보다 1이 크고, 요소는 첫 요소를 제외하고 모두 0으로 채워준다. [1, 0, 0, 0, 0, 0, 0, 0, 0,........ , 0] 
    // 이 배열의 각 요소는 type의 요소들(화폐 단위)을 사용해서 0부터 target+1까지 수들을 만들 수 있는 경우의 수이다. 0은 아무것도 고르지 않았을 때의 경우의 수인 1이 미리 할당되어 있고, 나머지 요소들도 경우의 수를 차차 채워 나갈 것이다.
    let arr = [1];
    for(let i = 0; i < target; i++) {
      arr.push(0); 
    }
    // arr를 1을 넣은 배열로 할당해 준 후, 반복문을 돌려서 0을 target만큼 push해주었다.

    type.map(function(ele) { // ele = 10, 20, 50
        arr[ele] += 1; // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1....1, .... , 1]
        // 여기까지가 type에 있는 요소들을 arr에 표시하는 작업이다.
        // 화폐 단위가 있으니 그 화폐 1장만을 선택했을 경우가 1로 표시된다.
        for (let i = ele + 1 ; i <= target ; i++) { 
            arr[i] += arr[i - ele];
            // arr에 표시를 해주는 방법:
            // map을 통한 이 작업은 type의 요소의 갯수만큼 반복한다.
            // ele가 10일 때 : i가 10부터 50까지 돌면서 표시를 한다.
            // debugger를 돌려서 과정을 꼭 살펴보자.
        }
    });
    return arr[target]; // 굉장히 긴 과정을 지나다보면 어느새 target번째에는 경우의 수가 target을 만드는 경우의 수가 들어와 있다.
}
```






