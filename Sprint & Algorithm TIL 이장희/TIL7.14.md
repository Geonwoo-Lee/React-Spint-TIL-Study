## 클로저(Closure)

---

클로저는 외부 함수의 지역 스코프에 내부 함수가 접근할 수 있고, 외부 함수가 소멸해도 내부 함수가 외부 함수의 지역 변수들을 사용할 수 있다면 이것을 클로저라고 부릅니다. 클로저는 보통 함수를 리턴하는 함수의 모양을 가지고 있지만 함수가 함수를 리턴한다고 무조건 클로저가 아닙니다. 클로저는 다음 아래와 같은 조건을 충족해야 합니다. <br />

### 클로저 조건
1. 내부함수가 익명함수로 되어 외부함수의 반환값으로 사용해야 합니다.<br />
2. 반환되는 내부함수는 외부함수의 실행환경에서 실행됩니다.<br />
3. 내부함수에서 사용하는 변수는 외부함수의 변수 스코프에 있어야 합니다.<br />

<br >

아래 간단한 클로저 예시를 통해 이해해봅시다!

```js
function 클로저(){
    let count = 0  // 3번조건
    return function(){  //1번조건
        return count++ 
    }
}

let 호출하장 = 클로저() //2번조건
호출하장() // 0
호출하장() // 1
호출하장() // 2
```

지금까지 클로저의 아주 기본적인 개념에 대해 알아보았습니다. 그러면 클로저는 언제 사용할까요 ?  
<br />


## 상태유지

클로저는 데이터가 변할때 현재 상태를 기억하고 변경된 최신 상태를 유지합니다. 다음 예제를 통해 이해해봅시다!

```js
function 나는유지할꺼얌(){
    let  변해랏 = false;
    console.log("outter "+ 변해랏)
    return function(){
        변해랏 = !변해랏
        console.log("inner "+ 변해랏)
    }
}

let 나는바껴욤 = 나는유지할꺼얌()
나는바껴욤() // inner true
나는바껴욤() // inner false
나는바껴욤() // inner true
나는유지할꺼얌() // outter false
나는바껴욤() // inner false
나는유지할꺼얌() // outter false
```

위에 있는 예제처럼 클로저는 현재 상태를 기억하고 있고 상태가 변경 된다면 바로 그 상태를 유지합니다. 토글버튼 구현할때 좋겠죵?  
<br />

## 커링

커링은 함수를 클로저를 이용해서 fn(a)(b)와 같은 형태로 만들어 인자를 하나씩만 받아 함수의 체인으로 만드는 방법입니다.

```js
function 커링(a){
    return function(b){
        return a + b;
    }
}

커링(5)(7); // 12
let 커링5씩더행 = 커링(5)

커링5씩더행(3) // 8
```

이러한 방법은 함수를 재사용하는데 유용하기 떄문에 많이 쓰는 기술입니다.
<br />
<br />

## 전역변수 사용 억제

클로저를 활용하여 전역 변수를 사용을 억제합니다. 만약 클로저를 활용하지 않으면 의도치 않게 변수가 변경되거나 변수 충돌이 일어날수있습니다.

```js
//클로저 사용 x
let count = 0

function 증가(){
    return ++count
}

증가() // 1
증가() // 2
증가() // 3
console.log(count) // 3
```

위에 예제는 count 변수가 너무 쉽게 접근이 가능하고 의도치 않게 변경 될 위험이 있습니다. 그래서 아래 와 같이 클로저를 이용해서 전역 변수의 사용 빈도를 줄여 충돌 위험을 방지합니다.

```js
function 카운터(){
    let count = 0

return function(){
    return ++count
  }
}
let 증가 = 카운터()

증가() // 1
증가() // 2
증가() // 3
카운터()() // 1
카운터()() // 1
증가() // 4
```
<br />

## 정보 은직, 캡슐화

함수 내의 정보를 은닉시켜 정보를 밖으로 노출 시키지 않는 방법입니다.

```js
function 카운터(){
    let num = 0

    this.증가 = function(){
        return ++num;
    };

    this.감소 = function(){
        return --num;
    };

    this.현재값 = function(){
        return num;
    };
}

const 숫자놀이 = new 카운터()

숫자놀이.증가() // 1
숫자놀이.증가() // 2
숫자놀이.감소() // 1
숫자놀이.현재값() // 1

숫자놀이.num // undefined
```

생성자 함수를 이용하여 함수를 객체화 하였고 카운터함수 내에 있는 num 변수는 this로 바인딩 되지 않은 그냥 변수 자체이기 때문에 객체화 된 카운터에서 num변수를 불러올 수 없게 됩니다
<br />

---
<br />

## 클로저의 장단점

클로저를 활용해서 메모제이션 기법을 사용할수 있습니다. 동일한 계산을 반복해야 할때, 이전 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술입니다. 하지만 클로저 패턴을 계속 사용하고 남발할 경우 메모리가 계속 쌓이기 떄문에 컴퓨터 성능이 저하가 될 수 있습니다!
